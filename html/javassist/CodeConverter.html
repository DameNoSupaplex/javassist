<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11) on Sat May 08 11:16:00 JST 2021 -->
<title>CodeConverter (Javassist API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-08">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CodeConverter (Javassist API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/CodeConverter.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">javassist</a></div>
<h2 title="Class CodeConverter" class="title">Class CodeConverter</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>javassist.CodeConverter</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">CodeConverter</span>
extends java.lang.Object</pre>
<div class="block">Simple translator of method bodies
 (also see the <code>javassist.expr</code> package).

 <p>Instances of this class specifies how to instrument of the
 bytecodes representing a method body.  They are passed to
 <code>CtClass.instrument()</code> or
 <code>CtMethod.instrument()</code> as a parameter.

 <p>Example:
 <pre>
 ClassPool cp = ClassPool.getDefault();
 CtClass point = cp.get("Point");
 CtClass singleton = cp.get("Singleton");
 CtClass client = cp.get("Client");
 CodeConverter conv = new CodeConverter();
 conv.replaceNew(point, singleton, "makePoint");
 client.instrument(conv);
 </pre>

 <p>This program substitutes "<code>Singleton.makePoint()</code>"
 for all occurrences of "<code>new Point()</code>"
 appearing in methods declared in a <code>Client</code> class.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="CtClass.html#instrument(javassist.CodeConverter)"><code>CtClass.instrument(CodeConverter)</code></a>, 
<a href="CtBehavior.html#instrument(javassist.CodeConverter)"><code>CtBehavior.instrument(CodeConverter)</code></a>, 
<a href="expr/ExprEditor.html" title="class in javassist.expr"><code>ExprEditor</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="CodeConverter.ArrayAccessReplacementMethodNames.html" title="interface in javassist">CodeConverter.ArrayAccessReplacementMethodNames</a></span></code></th>
<td class="colLast">
<div class="block">Interface containing the method names to be used
 as array access replacements.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="CodeConverter.DefaultArrayAccessReplacementMethodNames.html" title="class in javassist">CodeConverter.DefaultArrayAccessReplacementMethodNames</a></span></code></th>
<td class="colLast">
<div class="block">Default implementation of the <code>ArrayAccessReplacementMethodNames</code>
 interface giving default values for method names to be used for replacing
 accesses to array elements.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">CodeConverter</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertAfterMethod(javassist.CtMethod,javassist.CtMethod)">insertAfterMethod</a></span>&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                 <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;afterMethod)</code></th>
<td class="colLast">
<div class="block">Inserts a call to another method after an existing method call.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertBeforeMethod(javassist.CtMethod,javassist.CtMethod)">insertBeforeMethod</a></span>&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                  <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;beforeMethod)</code></th>
<td class="colLast">
<div class="block">Insert a call to another method before an existing method call.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#redirectFieldAccess(javassist.CtField,javassist.CtClass,java.lang.String)">redirectFieldAccess</a></span>&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                   <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass,
                   java.lang.String&nbsp;newFieldname)</code></th>
<td class="colLast">
<div class="block">Modify a method body so that field read/write expressions access
 a different field from the original one.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#redirectMethodCall(java.lang.String,javassist.CtMethod)">redirectMethodCall</a></span>&#8203;(java.lang.String&nbsp;oldMethodName,
                  <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;newMethod)</code></th>
<td class="colLast">
<div class="block">Correct invocations to a method that has been renamed.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#redirectMethodCall(javassist.CtMethod,javassist.CtMethod)">redirectMethodCall</a></span>&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                  <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;substMethod)</code></th>
<td class="colLast">
<div class="block">Modify method invocations in a method body so that a different
 method will be invoked.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#redirectMethodCallToStatic(javassist.CtMethod,javassist.CtMethod)">redirectMethodCallToStatic</a></span>&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                          <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;staticMethod)</code></th>
<td class="colLast">
<div class="block">Redirect non-static method invocations in a method body to a static
 method.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceArrayAccess(javassist.CtClass,javassist.CodeConverter.ArrayAccessReplacementMethodNames)">replaceArrayAccess</a></span>&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                  <a href="CodeConverter.ArrayAccessReplacementMethodNames.html" title="interface in javassist">CodeConverter.ArrayAccessReplacementMethodNames</a>&nbsp;names)</code></th>
<td class="colLast">
<div class="block">Modify a method body, so that ALL accesses to an array are replaced with 
 calls to static methods within another class.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceFieldRead(javassist.CtField,javassist.CtClass,java.lang.String)">replaceFieldRead</a></span>&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                java.lang.String&nbsp;calledMethod)</code></th>
<td class="colLast">
<div class="block">Modify a method body so that an expression reading the specified
 field is replaced with a call to the specified <i>static</i> method.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceFieldWrite(javassist.CtField,javassist.CtClass,java.lang.String)">replaceFieldWrite</a></span>&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                 <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                 java.lang.String&nbsp;calledMethod)</code></th>
<td class="colLast">
<div class="block">Modify a method body so that an expression writing the specified
 field is replaced with a call to the specified static method.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceNew(javassist.CtClass,javassist.CtClass)">replaceNew</a></span>&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;oldClass,
          <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass)</code></th>
<td class="colLast">
<div class="block">Modify a method body so that instantiation of the class
 specified by <code>oldClass</code>
 is replaced with instantiation of another class <code>newClass</code>.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#replaceNew(javassist.CtClass,javassist.CtClass,java.lang.String)">replaceNew</a></span>&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass,
          <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
          java.lang.String&nbsp;calledMethod)</code></th>
<td class="colLast">
<div class="block">Modify a method body so that instantiation of the specified class
 is replaced with a call to the specified static method.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CodeConverter</h4>
<pre>public&nbsp;CodeConverter()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="replaceNew(javassist.CtClass,javassist.CtClass,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceNew</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;replaceNew&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass,
                       <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                       java.lang.String&nbsp;calledMethod)</pre>
<div class="block">Modify a method body so that instantiation of the specified class
 is replaced with a call to the specified static method.  For example,
 <code>replaceNew(ctPoint, ctSingleton, "createPoint")</code>
 (where <code>ctPoint</code> and <code>ctSingleton</code> are
 compile-time classes for class <code>Point</code> and class
 <code>Singleton</code>, respectively)
 replaces all occurrences of:

 <pre>new Point(x, y)</pre>

 in the method body with:

 <pre>Singleton.createPoint(x, y)</pre>

 <p>This enables to intercept instantiation of <code>Point</code>
 and change the samentics.  For example, the following
 <code>createPoint()</code> implements the singleton pattern:

 <pre>public static Point createPoint(int x, int y) {
     if (aPoint == null)
         aPoint = new Point(x, y);
     return aPoint;
 }
 </pre>

 <p>The static method call substituted for the original <code>new</code>
 expression must be
 able to receive the same set of parameters as the original
 constructor.  If there are multiple constructors with different
 parameter types, then there must be multiple static methods
 with the same name but different parameter types.

 <p>The return type of the substituted static method must be
 the exactly same as the type of the instantiated class specified by
 <code>newClass</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newClass</code> - the instantiated class.</dd>
<dd><code>calledClass</code> - the class in which the static method is
                          declared.</dd>
<dd><code>calledMethod</code> - the name of the static method.</dd>
</dl>
</li>
</ul>
<a id="replaceNew(javassist.CtClass,javassist.CtClass)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceNew</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;replaceNew&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;oldClass,
                       <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass)</pre>
<div class="block">Modify a method body so that instantiation of the class
 specified by <code>oldClass</code>
 is replaced with instantiation of another class <code>newClass</code>.
 For example,
 <code>replaceNew(ctPoint, ctPoint2)</code>
 (where <code>ctPoint</code> and <code>ctPoint2</code> are
 compile-time classes for class <code>Point</code> and class
 <code>Point2</code>, respectively)
 replaces all occurrences of:

 <pre>new Point(x, y)</pre>

 in the method body with:

 <pre>new Point2(x, y)</pre>

 <p>Note that <code>Point2</code> must be type-compatible with <code>Point</code>.
 It must have the same set of methods, fields, and constructors as the
 replaced class.</div>
</li>
</ul>
<a id="redirectFieldAccess(javassist.CtField,javassist.CtClass,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>redirectFieldAccess</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;redirectFieldAccess&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                                <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;newClass,
                                java.lang.String&nbsp;newFieldname)</pre>
<div class="block">Modify a method body so that field read/write expressions access
 a different field from the original one.

 <p>Note that this method changes only the filed name and the class
 declaring the field; the type of the target object does not change.
 Therefore, the substituted field must be declared in the same class
 or a superclass of the original class.

 <p>Also, <code>clazz</code> and <code>newClass</code> must specify
 the class directly declaring the field.  They must not specify
 a subclass of that class.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>field</code> - the originally accessed field.</dd>
<dd><code>newClass</code> - the class declaring the substituted field.</dd>
<dd><code>newFieldname</code> - the name of the substituted field.</dd>
</dl>
</li>
</ul>
<a id="replaceFieldRead(javassist.CtField,javassist.CtClass,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceFieldRead</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;replaceFieldRead&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                             <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                             java.lang.String&nbsp;calledMethod)</pre>
<div class="block">Modify a method body so that an expression reading the specified
 field is replaced with a call to the specified <i>static</i> method.
 This static method receives the target object of the original
 read expression as a parameter.  It must return a value of
 the same type as the field.

 <p>For example, the program below

 <pre>Point p = new Point();
 int newX = p.x + 3;</pre>

 <p>can be translated into:

 <pre>Point p = new Point();
 int newX = Accessor.readX(p) + 3;</pre>

 <p>where

 <pre>public class Accessor {
     public static int readX(Object target) { ... }
 }</pre>

 <p>The type of the parameter of <code>readX()</code> must
 be <code>java.lang.Object</code> independently of the actual
 type of <code>target</code>.  The return type must be the same
 as the field type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>field</code> - the field.</dd>
<dd><code>calledClass</code> - the class in which the static method is
                          declared.</dd>
<dd><code>calledMethod</code> - the name of the static method.</dd>
</dl>
</li>
</ul>
<a id="replaceFieldWrite(javassist.CtField,javassist.CtClass,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceFieldWrite</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;replaceFieldWrite&#8203;(<a href="CtField.html" title="class in javassist">CtField</a>&nbsp;field,
                              <a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                              java.lang.String&nbsp;calledMethod)</pre>
<div class="block">Modify a method body so that an expression writing the specified
 field is replaced with a call to the specified static method.
 This static method receives two parameters: the target object of
 the original
 write expression and the assigned value.  The return type of the
 static method is <code>void</code>.

 <p>For example, the program below

 <pre>Point p = new Point();
 p.x = 3;</pre>

 <p>can be translated into:

 <pre>Point p = new Point();
 Accessor.writeX(3);</pre>

 <p>where

 <pre>public class Accessor {
     public static void writeX(Object target, int value) { ... }
 }</pre>

 <p>The type of the first parameter of <code>writeX()</code> must
 be <code>java.lang.Object</code> independently of the actual
 type of <code>target</code>.  The type of the second parameter
 is the same as the field type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>field</code> - the field.</dd>
<dd><code>calledClass</code> - the class in which the static method is
                          declared.</dd>
<dd><code>calledMethod</code> - the name of the static method.</dd>
</dl>
</li>
</ul>
<a id="replaceArrayAccess(javassist.CtClass,javassist.CodeConverter.ArrayAccessReplacementMethodNames)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceArrayAccess</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;replaceArrayAccess&#8203;(<a href="CtClass.html" title="class in javassist">CtClass</a>&nbsp;calledClass,
                               <a href="CodeConverter.ArrayAccessReplacementMethodNames.html" title="interface in javassist">CodeConverter.ArrayAccessReplacementMethodNames</a>&nbsp;names)
                        throws <a href="NotFoundException.html" title="class in javassist">NotFoundException</a></pre>
<div class="block">Modify a method body, so that ALL accesses to an array are replaced with 
 calls to static methods within another class. In the case of reading an 
 element from the array, this is replaced with a call to a static method with 
 the array and the index as arguments, the return value is the value read from 
 the array. If writing to an array, this is replaced with a call to a static 
 method with the array, index and new value as parameters, the return value of 
 the static method is <code>void</code>.
 
 <p>The <code>calledClass</code> parameter is the class containing the static methods to be used 
 for array replacement. The <code>names</code> parameter points to an implementation of 
 <code>ArrayAccessReplacementMethodNames</code> which specifies the names of the method to be 
 used for access for each type of array.  For example reading from an <code>int[]</code> will 
 require a different method than if writing to an <code>int[]</code>, and writing to a <code>long[]</code> 
 will require a different method than if writing to a <code>byte[]</code>. If the implementation 
 of <code>ArrayAccessReplacementMethodNames</code> does not contain the name for access for a 
 type of array, that access is not replaced.
 
 <p>A default implementation of <code>ArrayAccessReplacementMethodNames</code> called 
 <code>DefaultArrayAccessReplacementMethodNames</code> has been provided and is what is used in the 
 following example. This also assumes that <code>'foo.ArrayAdvisor'</code> is the name of the 
 <code>CtClass</code> passed in.
 
 <p>If we have the following class:
 <pre>class POJO{
    int[] ints = new int[]{1, 2, 3, 4, 5};
    long[] longs = new int[]{10, 20, 30};
    Object objects = new Object[]{true, false};
    Integer[] integers = new Integer[]{new Integer(10)};
 }
 </pre>
 and this is accessed as:
 <pre>POJO p = new POJO();
 
 //Write to int array
 p.ints[2] = 7;
 
 //Read from int array
 int i = p.ints[2];
 
 //Write to long array
 p.longs[2] = 1000L;
 
 //Read from long array
 long l = p.longs[2];
 
 //Write to Object array
 p.objects[2] = "Hello";
 
 //Read from Object array
 Object o = p.objects[2];
 
 //Write to Integer array
 Integer integer = new Integer(5);
 p.integers[0] = integer;
 
 //Read from Object array
 integer = p.integers[0];
 </pre>
 
 Following instrumentation we will have
 <pre>POJO p = new POJO();
 
 //Write to int array
 ArrayAdvisor.arrayWriteInt(p.ints, 2, 7);
 
 //Read from int array
 int i = ArrayAdvisor.arrayReadInt(p.ints, 2);
 
 //Write to long array
 ArrayAdvisor.arrayWriteLong(p.longs, 2, 1000L);
 
 //Read from long array
 long l = ArrayAdvisor.arrayReadLong(p.longs, 2);
 
 //Write to Object array
 ArrayAdvisor.arrayWriteObject(p.objects, 2, "Hello");
 
 //Read from Object array
 Object o = ArrayAdvisor.arrayReadObject(p.objects, 2);
 
 //Write to Integer array
 Integer integer = new Integer(5);
 ArrayAdvisor.arrayWriteObject(p.integers, 0, integer);
 
 //Read from Object array
 integer = ArrayAdvisor.arrayWriteObject(p.integers, 0);
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>calledClass</code> - the class containing the static methods.</dd>
<dd><code>names</code> - contains the names of the methods to replace
                           the different kinds of array access with.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NotFoundException.html" title="class in javassist">NotFoundException</a></code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="CodeConverter.DefaultArrayAccessReplacementMethodNames.html" title="class in javassist"><code>CodeConverter.DefaultArrayAccessReplacementMethodNames</code></a></dd>
</dl>
</li>
</ul>
<a id="redirectMethodCall(javassist.CtMethod,javassist.CtMethod)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>redirectMethodCall</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;redirectMethodCall&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                               <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;substMethod)
                        throws <a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></pre>
<div class="block">Modify method invocations in a method body so that a different
 method will be invoked.

 <p>Note that the target object, the parameters, or
 the type of invocation
 (static method call, interface call, or private method call)
 are not modified.  Only the method name is changed.  The substituted
 method must have the same signature that the original one has.
 If the original method is a static method, the substituted method
 must be static.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origMethod</code> - original method</dd>
<dd><code>substMethod</code> - substituted method</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></code></dd>
</dl>
</li>
</ul>
<a id="redirectMethodCall(java.lang.String,javassist.CtMethod)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>redirectMethodCall</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;redirectMethodCall&#8203;(java.lang.String&nbsp;oldMethodName,
                               <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;newMethod)
                        throws <a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></pre>
<div class="block">Correct invocations to a method that has been renamed.
 If a method is renamed, calls to that method must be also
 modified so that the method with the new name will be called.

 <p>The method must be declared in the same class before and
 after it is renamed.

 <p>Note that the target object, the parameters, or
 the type of invocation
 (static method call, interface call, or private method call)
 are not modified.  Only the method name is changed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oldMethodName</code> - the old name of the method.</dd>
<dd><code>newMethod</code> - the method with the new name.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></code></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="CtMethod.html#setName(java.lang.String)"><code>CtMethod.setName(String)</code></a></dd>
</dl>
</li>
</ul>
<a id="redirectMethodCallToStatic(javassist.CtMethod,javassist.CtMethod)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>redirectMethodCallToStatic</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;redirectMethodCallToStatic&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                                       <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;staticMethod)</pre>
<div class="block">Redirect non-static method invocations in a method body to a static
 method. The return type must be same with the originally invoked method.
 As parameters, the static method receives
 the target object and all the parameters to the originally invoked
 method.  For example, if the originally invoked method is
 <code>move()</code>:

 <pre>class Point {
     Point move(int x, int y) { ... }
 }</pre>

 <p>Then the static method must be something like this:

 <pre>class Verbose {
     static Point print(Point target, int x, int y) { ... }
 }</pre>

 <p>The <code>CodeConverter</code> would translate bytecode
 equivalent to:

 <pre>Point p2 = p.move(x + y, 0);</pre>

 <p>into the bytecode equivalent to:

 <pre>Point p2 = Verbose.print(p, x + y, 0);</pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origMethod</code> - original method</dd>
<dd><code>staticMethod</code> - static method</dd>
</dl>
</li>
</ul>
<a id="insertBeforeMethod(javassist.CtMethod,javassist.CtMethod)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertBeforeMethod</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;insertBeforeMethod&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                               <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;beforeMethod)
                        throws <a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></pre>
<div class="block">Insert a call to another method before an existing method call.
 That "before" method must be static.  The return type must be
 <code>void</code>.  As parameters, the before method receives
 the target object and all the parameters to the originally invoked
 method.  For example, if the originally invoked method is
 <code>move()</code>:

 <pre>class Point {
     Point move(int x, int y) { ... }
 }</pre>

 <p>Then the before method must be something like this:

 <pre>class Verbose {
     static void print(Point target, int x, int y) { ... }
 }</pre>

 <p>The <code>CodeConverter</code> would translate bytecode
 equivalent to:

 <pre>Point p2 = p.move(x + y, 0);</pre>

 <p>into the bytecode equivalent to:

 <pre>int tmp1 = x + y;
 int tmp2 = 0;
 Verbose.print(p, tmp1, tmp2);
 Point p2 = p.move(tmp1, tmp2);</pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origMethod</code> - the method originally invoked.</dd>
<dd><code>beforeMethod</code> - the method invoked before
                          <code>origMethod</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></code></dd>
</dl>
</li>
</ul>
<a id="insertAfterMethod(javassist.CtMethod,javassist.CtMethod)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>insertAfterMethod</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;insertAfterMethod&#8203;(<a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;origMethod,
                              <a href="CtMethod.html" title="class in javassist">CtMethod</a>&nbsp;afterMethod)
                       throws <a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></pre>
<div class="block">Inserts a call to another method after an existing method call.
 That "after" method must be static.  The return type must be
 <code>void</code>.  As parameters, the after method receives
 the target object and all the parameters to the originally invoked
 method.  For example, if the originally invoked method is
 <code>move()</code>:

 <pre>class Point {
     Point move(int x, int y) { ... }
 }</pre>

 <p>Then the after method must be something like this:

 <pre>class Verbose {
     static void print(Point target, int x, int y) { ... }
 }</pre>

 <p>The <code>CodeConverter</code> would translate bytecode
 equivalent to:

 <pre>Point p2 = p.move(x + y, 0);</pre>

 <p>into the bytecode equivalent to:

 <pre>
 int tmp1 = x + y;
 int tmp2 = 0;
 Point p2 = p.move(tmp1, tmp2);
 Verbose.print(p, tmp1, tmp2);</pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>origMethod</code> - the method originally invoked.</dd>
<dd><code>afterMethod</code> - the method invoked after
                          <code>origMethod</code>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="CannotCompileException.html" title="class in javassist">CannotCompileException</a></code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/CodeConverter.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><i>Javassist, a Java-bytecode translator toolkit.<br>
Copyright (C) 1999- Shigeru Chiba. All Rights Reserved.</i></small></p>
</footer>
</body>
</html>
